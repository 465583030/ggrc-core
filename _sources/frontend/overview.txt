Overview
========

This document is a reference for anyone interested in understanding how
GGRC is constructed. The goal for this document is to explain how
everything works in moderate detail with references to source code which
can be used to understand in exact detail how GGRC works.

Client Side
-----------


Overview
~~~~~~~~

The client-side of GGRC is initially constructed from templates and/or
views defined and rendered on the server. The templates and views
provide a scaffolding for the UI. Rendering those elements invokes
JavaScript code which bootstraps the majority of the client-side of GGRC
which is constructed from CanJS Controls, Components and Mustache templates.

Once the Controls are rendered, they take control of generating the
remainder of the UI and attaching all relevant logic and user
interaction handlers.

There are two main objects that are useful in managing the data model:

-  ``GGRC``
-  ``CMS``

For example, ``GGRC.page_instance()`` returns the current page instance,
and ``GGRC.page_object`` is the object rendered by the current page
(e.g. a Program), as it was received from the server (mapped objects are
stubs).

``CMS.Models.<MODEL>.cache`` stores the loaded objects. For example,
``CMS.Models.Program.cache`` will have an array of all the loaded
programs.

Client-side File Manifests
~~~~~~~~~~~~~~~~~~~~~~~~~~

Mustache templates need to be referenced
from a manifest file in order for it to be usable in constructing the
UI.

These manifest files live in ``src/<module>/assets/assets.yaml``.

Javascript resources are bundled together using webpack.

Page Structure
~~~~~~~~~~~~~~

.. figure:: /_static/res/page_structure.png
   :alt: Page structure

   Page structure


.. _advanced-search:

Advanced search
~~~~~~~~~~~~~~~

``Advanced Search`` feature in GGRC provides a user simple way to perform
complicated search accross required data. The feature allows to search objects
both by attributes and mappings.
Search by attributes include possibility to find object by any attributes
it has with “Contains”, “Equals”, “Does not contain”, “Is not equal”,
“Lesser than”, “Greater than” attributes.
Search by mappings allows to search objects by any level of mappings
(for example, “I would like to find a Control that is mapped to Program A,
where Program A is mapped to Regulation B and etc.). User is also able to
construct complex group expression with “AND”, “OR” conditions
(for example, “I would like to find a Control that is mapped to Program A
AND that is mapped to Regulation B and etc.)
``Advanced Search`` except tree view also integrated with Mapping and Global
search modals (:ref:`mapping-and-global-search`)
``Advanced Search`` UI generate a complex query to :ref:`advanced-query-api`
in order to fetch data from server side.

.. figure:: /_static/res/advanced-search.png


QuickFormController
~~~~~~~~~~~~~~~~~~~

This controller derives from the Modals controller in that it takes form
input, converts it into properties on model instances, and saves the
changes back to the server. A primary difference in QuickForm is that
any update to the instance triggered by QuickForm results in an
immediate save(). Also, QuickForm was created with the expectation that
the instance already exists on the server; attempts to work with new
model instances before first save may result in unexpected behavior.

-  How do controllers interact with controls?
-  How do controllers interact with the backend?

View
~~~~

View templates are implemented all in JavaScript with the help of Mustache.

Components
~~~~~~~~~~

To build the UI are used components and are in the directory
``assets/javascripts/components``

Standard view templates
^^^^^^^^^^^^^^^^^^^^^^^

Several standard view fragments are defined for each type of entity
within GGRC. Additional fragments can be created and utilized as needed.
But these templates are the main templates from which the majority of
the UI is created.

-  ``info.mustache`` - Defines the “Info” widget on each object’s page.
    Defined per-widget in GGRC.Controllers.InfoWidget as the
   ``widget_view`` option, and specified using ``GGRC.WidgetList``
   definitions.
-  ``extended_info.mustache`` - Defines the content of an object’s
   tooltip/popover in the LHN lists.  Specified as the ``tooltip_view``
   parameter when rendering
   :src:`ggrc/assets/mustache/dashboard/lhn.mustache`.
-  ``modal_content.mustache`` - Defines the view for modal “create” or
   “edit” form functionality.  For most objects, this path is
   automatically generated using the ``data-template`` or
   ``data-object-plural`` attributes of the invoking element (see
   ``bootstrap/modal-ajax.js``.

Where to find view templates
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The view files are in the following folder within a module
``src/<module>/assets/mustache/``.

For example, the ``ggrc_workflow`` views are in the following folder
:src:`ggrc_workflows/assets/mustache/`

View Helpers
^^^^^^^^^^^^

View helpers are defined using the Mustache `helper mechanism provided
by CanJS <http://canjs.com/docs/can.mustache.Helpers.html>`_.  Core
helpers are specified in
:src:`ggrc/assets/javascripts/mustache_helpers.js`,
and extension helpers should be specified in a file named similar to
``src/<module_name>/assets/javascripts/<class_name>_mustache_helpers.js``.

Events
~~~~~~

Client-side event firing/handling is handled through CanJS, which is
primarily based on jQuery event handling.

Program Flow
~~~~~~~~~~~~

Legacy part of client-side logic is implemented in Controls. Much of this logic is
implemented using asynchronous callbacks via
`can.Deferred <http://canjs.com/docs/can.Deferred.html>`_.
All new features are written in component-based approach.

Error Handling
~~~~~~~~~~~~~~

Most errors are reported to the system with a ``window.onerror`` handler
that generates flash messages at the top of the page and reports the
exception back to Tracker. For maximum coverage, the script that defines
this handler is inlined into base.haml.

AJAX failures that happen while a modal is active are reported back to a
flash handler at the modal level (so that the flash messages are not
covered by modals or overlays).

Because the error handler at the window level handles most of our needs,
try/catch blocks are rare in GGRC. However, it is worth noting that
errors in Deferred callbacks may not fire the onerror handler, *and*
"break the chain" inasmuch as the state of the deferred never changes
from "pending" after that, and other deferreds waiting for the result of
that deferred will never run. This is a failure of the jQuery Deferred
object to sensibly handle uncaught errors (they should reject the
deferred instead). In the case where it's possible that a callback will
throw an error, it is recommended to wrap the content of the callback in
``try/catch`` and return a rejected deferred when an error happens.
